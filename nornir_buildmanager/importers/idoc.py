'''

Imports .idoc files generated by `SerialEM`_.  The importer expects the input
path to be a folder containing a seperate subfolder for each section.  Section
subfolders should be named with the section number.  An optional 
underscore may follow the section number with a friendly name for the section.

Section subfolders should contain the .idoc file, any images associated with the 
.idoc, an optional notes.txt file, and the .log generated during capture by SerialEM. 

Example:

* BobcatSeriesForBob

  * 0001_EggID4567

    * capture.idoc
    * capture.log
    * notes.txt
    * 001.tif
    * 002.tif
    * ...
    * 1245.tif

  * 0002_EggID7645

    * ... 

.. _SerialEM: http://bio3d.colorado.edu/SerialEM/

'''

import sys
import re
import cPickle as pickle
import nornir_buildmanager.templates
from nornir_buildmanager.VolumeManagerETree import *
from nornir_buildmanager.operations.tile import VerifyTiles
import nornir_buildmanager.importers
from nornir_imageregistration.files import mosaicfile
from nornir_imageregistration.mosaic import Mosaic
from nornir_imageregistration import image_stats
from nornir_shared.images import *
import nornir_shared.files as files
from nornir_shared.histogram import *
from nornir_shared.mathhelper import ListMedian
from nornir_shared.files import RemoveOutdatedFile
import nornir_shared.plot as plot
import logging
import collections
import nornir_pools
import numpy


def Import(VolumeElement, ImportPath, extension=None, *args, **kwargs):
    '''Import the specified directory into the volume'''
    
    if extension is None:
        extension = 'idoc'
        
    FlipList = nornir_buildmanager.importers.GetFlipList(ImportPath)
    histogramFilename = os.path.join(ImportPath, nornir_buildmanager.importers.DefaultHistogramFilename)
    ContrastMap = nornir_buildmanager.importers.LoadHistogramCutoffs(histogramFilename)
    if len(ContrastMap) == 0:
        nornir_buildmanager.importers.CreateDefaultHistogramCutoffFile(histogramFilename)

    DirList = files.RecurseSubdirectoriesGenerator(ImportPath, RequiredFiles="*." + extension, ExcludeNames=[], ExcludedDownsampleLevels=[])
    for path in DirList:
        for idocFullPath in glob.glob(os.path.join(path, '*.idoc')):
            yield SerialEMIDocImport.ToMosaic(VolumeElement, idocFullPath, VolumeElement.FullPath, FlipList=FlipList, ContrastMap=ContrastMap)
              
def try_remove_spaces_from_dirname(sectionDir):
    ''':return: Renamed directory if there were spaced in the filename, otherwise none'''
    sectionDirNoSpaces = sectionDir.replace(' ', '_')
    ParentDir = os.path.dirname(sectionDir)
    if(sectionDirNoSpaces != sectionDir):
        sectionDirNoSpacesFullPath = os.path.join(ParentDir, sectionDirNoSpaces)
        shutil.move(sectionDir, sectionDirNoSpacesFullPath)

        sectionDir = sectionDirNoSpaces
        return sectionDir 
    
    
    return None

class SerialEMIDocImport(object):
    
    @classmethod 
    def _Update_idoc_path_on_rename(cls, idocFileFullPath, new_section_dir):
        '''Return the correct paths if we move the directory a section lives in'''
        
        idocFilename = os.path.basename(idocFileFullPath)
        (ParentDir, sectionDir) = cls.GetDirectories(idocFileFullPath)
        
        sectionDir = os.path.join(ParentDir, new_section_dir)
        idocFileFullPath = os.path.join(sectionDir, idocFilename)
        
        return idocFileFullPath
        
    
    @classmethod
    def GetDirectories(cls, idocFileFullPath):
        sectionDir = os.path.dirname(idocFileFullPath)
        ParentDir = os.path.dirname(sectionDir)
        return (ParentDir, sectionDir)
    
    @classmethod
    def GetIDocPathWithoutSpaces(cls, idocFileFullPath):
        sectionDir = os.path.dirname(idocFileFullPath)
        fixed_sectionDir = try_remove_spaces_from_dirname(sectionDir)
        if fixed_sectionDir is None:
            return idocFileFullPath
        else:
            return cls._Update_idoc_path_on_rename(idocFileFullPath, fixed_sectionDir)

    @classmethod
    def GetSectionInfo(cls, fileName):
        fileName = os.path.basename(fileName)

        # Make sure extension is present in the filename
        [fileName, ext] = os.path.splitext(fileName)

        SectionNumber = -1
        Downsample = 1
        parts = fileName.split("_")
        try:
            SectionNumber = int(parts[0])
        except:
            # We really can't recover from this, so maybe an exception should be thrown instead
            SectionNumber = -1

        try:
            SectionName = parts[1]
        except:
            SectionName = str(SectionNumber)

        # If we don't have a valid downsample value we assume 1
        try:
            DownsampleStrings = parts[2].split(".")
            Downsample = int(DownsampleStrings[0])
        except:
            Downsample = 1

        return [SectionNumber, SectionName, Downsample]

    @classmethod
    def ToMosaic(cls, VolumeObj, idocFileFullPath, OutputPath=None, Extension=None, OutputImageExt=None, TileOverlap=None, TargetBpp=None, FlipList=None, ContrastMap=None, debug=None):
        '''
        This function will convert an idoc file in the given path to a .mosaic file.
        It will also rename image files to the requested extension and subdirectory.
        TargetBpp is calculated based on the number of bits required to encode the values
        between the median min and max values
        :param list FlipList: List of section numbers which should have images flipped
        :param dict ContrastMap: Dictionary mapping section number to (Min, Max, Gamma) tuples 
        '''
        if(OutputImageExt is None):
            OutputImageExt = 'png'

        if(Extension is None):
            Extension = 'idoc'
            
        if TargetBpp is None:
            TargetBpp = 8
            
        if FlipList is None:
            FlipList = []
            
        if ContrastMap is None:
            ContrastMap = {}
            
        idocFilePath = cls.GetIDocPathWithoutSpaces(idocFileFullPath)

        # Default to the directory above ours if an output path is not specified
        if OutputPath is None:
            OutputPath = os.path.join(idocFilePath, "..")

        if not os.path.exists(OutputPath):
            os.makedirs(OutputPath)

        logger = logging.getLogger(__name__ + '.' + str(cls.__name__) + "ToMosaic")

        # VolumeObj = VolumeManager.Load(OutputPath, Create=True)

        # Report the current stage to the user
        prettyoutput.CurseString('Stage', "SerialEM to Mosaic " + str(idocFileFullPath))

        SectionNumber = 0
        (ParentDir, sectionDir) = cls.GetDirectories(idocFileFullPath)
          
        BlockObj = BlockNode('TEM')
        [saveBlock, BlockObj] = VolumeObj.UpdateOrAddChild(BlockObj)
         
        # If the parent directory doesn't have the section number in the name, change it
        ExistingSectionInfo = cls.GetSectionInfo(sectionDir)
        if(ExistingSectionInfo[0] < 0):
            i = 5
#            SectionNumber = SectionNumber + 1
#            newPathName = ('%' + nornir_buildmanager.templates.Current.SectionFormat) % SectionNumber + '_' + sectionDir
#            newPath = os.path.join(ParentDir, newPathName)
#            prettyoutput.Log('Moving: ' + InputPath + ' -> ' + newPath)
#            shutil.move(InputPath, newPath)
#
#            InputPath = newPath
#
#            #Run glob again because the dir changes
#            idocFiles = glob.glob(os.path.join(InputPath,'*.idoc'))
        else:
            SectionNumber = ExistingSectionInfo[0]

        prettyoutput.CurseString('Section', str(SectionNumber))
 

        # Check for underscores.  If there is an underscore and the first part is the sectionNumber, then use everything after as the section name
        SectionName = ('%' + nornir_buildmanager.templates.Current.SectionFormat) % SectionNumber
        SectionPath = ('%' + nornir_buildmanager.templates.Current.SectionFormat) % SectionNumber
        try:
            parts = sectionDir.partition("_")
            if not parts is None:
                if len(parts[2]) > 0:
                    SectionName = parts[2]
        except:
            pass

        sectionObj = SectionNode(SectionNumber,
                                              SectionName,
                                              SectionPath)

        [saveSection, sectionObj] = BlockObj.UpdateOrAddChildByAttrib(sectionObj, 'Number')
        sectionObj.Name = SectionName

        # Create a channel group 
        [saveChannel, channelObj] = sectionObj.UpdateOrAddChildByAttrib(ChannelNode('TEM'), 'Name')
  
        ChannelPath = channelObj.FullPath
        OutputSectionPath = os.path.join(OutputPath, ChannelPath)
        # Create a channel group for the section

        # I started ignoring existing supertile.mosaic files so I could rebuild sections where
        # a handful of tiles were corrupt
        # if(os.path.exists(SupertilePath)):
        #    continue

        Flip = SectionNumber in FlipList;
        if(Flip):
            prettyoutput.Log("Found in FlipList.txt, flopping images")

        IDocData = IDoc.Load(idocFilePath)

        assert(hasattr(IDocData, 'PixelSpacing'))
        assert(hasattr(IDocData, 'DataMode'))
        assert(hasattr(IDocData, 'ImageSize'))

        # If there are no tiles... return
        if IDocData.NumTiles == 0:
            prettyoutput.Log("No tiles found in IDoc: " + idocFilePath)
            return
        
        # See if we can find a notes file...
        TryAddNotes(channelObj, sectionDir, logger)
        TryAddLogs(channelObj, sectionDir, logger)

        AddIdocNode(channelObj, idocFilePath, IDocData, logger)

        # Set the scale
        [added, ScaleObj] = cls.CreateScaleNode(IDocData, channelObj) 

       
        FilterName = 'Raw' + str(TargetBpp)
        if(TargetBpp is None):
            FilterName = 'Raw'
        
        
        histogramFullPath = os.path.join(sectionDir, 'Histogram.xml')
        source_tile_list = [os.path.join(sectionDir, t.Image) for t in IDocData.tiles ]
        (ActualMosaicMin, ActualMosaicMax, Gamma) = cls.GetSectionContrastSettings(SectionNumber, ContrastMap, source_tile_list, histogramFullPath)
        ActualMosaicMax = numpy.around(ActualMosaicMax)
        ActualMosaicMin = numpy.around(ActualMosaicMin)
        _PlotHistogram(histogramFullPath, SectionNumber, ActualMosaicMin, ActualMosaicMax)
            
        channelObj.RemoveFilterOnContrastMismatch(FilterName, ActualMosaicMin, ActualMosaicMax, Gamma)
        
        ImageConversionRequired = False

        # Create a channel for the Raw data 
        [added_filter, filterObj] = channelObj.UpdateOrAddChildByAttrib(FilterNode(Name=FilterName), 'Name')
        if added_filter:
            ImageConversionRequired = True
        
        filterObj.SetContrastValues(ActualMosaicMin, ActualMosaicMax, Gamma)
        filterObj.BitsPerPixel = TargetBpp

        SupertileName = 'Stage'
        SupertileTransform = SupertileName + '.mosaic'
        SupertilePath = os.path.join(OutputSectionPath, SupertileTransform)

        # Check to make sure our supertile mosaic file is valid
        RemoveOutdatedFile(idocFilePath, SupertilePath)

        [added_transform, transformObj] = channelObj.UpdateOrAddChildByAttrib(TransformNode(Name=SupertileName,
                                                                         Path=SupertileTransform,
                                                                         Type='Stage'),
                                                                         'Path')
 
        
        [added_tilepyramid, PyramidNodeObj] = filterObj.UpdateOrAddChildByAttrib(TilePyramidNode(Type='stage',
                                                                            NumberOfTiles=IDocData.NumTiles),
                                                                            'Path')

        LevelObj = PyramidNodeObj.GetOrCreateLevel(1, GenerateData=False)
        
        Tileset = NornirTileset.CreateTilesFromIDocTileData(IDocData.tiles, InputTileDir=sectionDir, OutputTileDir=LevelObj.FullPath, OutputImageExt=OutputImageExt)
        
            
        # Parse the images
        ImageBpp = cls.GetImageBpp(IDocData, sectionDir)
        
                
        # Make sure the target LevelObj is verified        
        if not os.path.exists(LevelObj.FullPath):
            os.makedirs(LevelObj.FullPath)
        else:
            VerifyTiles(filterObj.TilePyramid.GetLevel(1))
            Tileset.RemoveStaleTilesFromOutputDir(SupertilePath=SupertilePath)
            
        SourceToMissingTargetMap = Tileset.GetSourceToMissingTargetMap()
         
        # Figure out if we have to move or convert images
        if len(SourceToMissingTargetMap) == 0:
            ImageConversionRequired = False
        else:
            ImageConversionRequired = (not ImageBpp == TargetBpp) or (ImageConversionRequired | Tileset.ImageConversionRequired)

        if(ImageConversionRequired):
            Invert = False 
            filterObj.SetContrastValues(ActualMosaicMin, ActualMosaicMax, Gamma)
            filterObj.TilePyramid.NumberOfTiles = IDocData.NumTiles
            #andValue = cls.GetBitmask(ActualMosaicMin, ActualMosaicMax, TargetBpp)
            nornir_shared.images.ConvertImagesInDict(SourceToMissingTargetMap, Flip=Flip, Bpp=TargetBpp, Invert=Invert, bDeleteOriginal=False, MinMax=[ActualMosaicMin, ActualMosaicMax])
            
        elif(Tileset.ImageMoveRequired):
            for f in SourceToMissingTargetMap:
                shutil.copy(f, SourceToMissingTargetMap[f])

        # If we wrote new images replace the .mosaic file
        if len(SourceToMissingTargetMap) > 0 or not os.path.exists(SupertilePath):
            # Writing this file indicates import succeeded and we don't need to repeat these steps, writing it will possibly invalidate a lot of downstream data
            # We need to flip the images.  This may be a Utah scope issue, our Y coordinates are inverted relative to the images.  To fix this
            # we flop instead of flip and reverse when writing the coordinates
            mosaicfile.MosaicFile.Write(SupertilePath, Entries=Tileset.GetPositionsForTargets(), Flip=not Flip, ImageSize=IDocData.ImageSize, Downsample=1);
            MFile = mosaicfile.MosaicFile.Load(SupertilePath)

            # Sometimes files fail to convert, when this occurs remove them from the .mosaic
            if MFile.RemoveInvalidMosaicImages(LevelObj.FullPath):
                MFile.Save(SupertilePath)
 
            Mosaic.TranslateMosaicFileToZeroOrigin(SupertilePath)
            transformObj.ResetChecksum()
            # transformObj.Checksum = MFile.Checksum
            
        if saveBlock:
            return VolumeObj
        elif saveSection:
            return BlockObj
        elif saveChannel:
            return sectionObj
        else:
            return channelObj
    
    
    @classmethod
    def GetSectionContrastSettings(cls, SectionNumber, ContrastMap, SourceImagesFullPaths, histogramFullPath):
        '''Clear and recreate the filters tile pyramid node if the filters contrast node does not match'''
        ActualMosaicMin = None
        ActualMosaicMax = None
        Gamma = 1.0
        if SectionNumber in ContrastMap:
            ActualMosaicMin = ContrastMap[SectionNumber].Min
            ActualMosaicMax = ContrastMap[SectionNumber].Max
            Gamma = ContrastMap[SectionNumber].Gamma
        else:
            (ActualMosaicMin, ActualMosaicMax) = _GetMinMaxCutoffs(SourceImagesFullPaths, histogramFullPath)
        
        return (ActualMosaicMin, ActualMosaicMax, Gamma)
        
    
    @classmethod
    def GetImageBpp(cls, IDocData, sectionDir):
        ImageBpp = IDocData.GetImageBpp()
        if ImageBpp is None:
            # Figure out the bit depth of the input
            tile = IDocData.tiles[0] 
            SourceImageFullPath = os.path.join(sectionDir, tile.Image)
            ImageBpp = GetImageBpp(SourceImageFullPath)
        if(not ImageBpp is None):
            prettyoutput.Log("Source images are " + str(ImageBpp) + " bits per pixel")
        else:
            prettyoutput.Log("Could not determine source image BPP")
            raise ValueError("Could not determine source image BPP")
        
        return ImageBpp
    
    @classmethod
    def CreateScaleNode(cls, IDocData, channelObj):
        '''Create a scale node for the channel
        :return: ScaleNode object that was created'''
        scaleValueInNm = float(IDocData.PixelSpacing) / 10.0
        [added, ScaleObj] = channelObj.UpdateOrAddChild(XElementWrapper('Scale'))

        ScaleObj.UpdateOrAddChild(XElementWrapper('X', {'UnitsOfMeasure' : 'nm',
                                                             'UnitsPerPixel' : str(scaleValueInNm)}))
        ScaleObj.UpdateOrAddChild(XElementWrapper('Y', {'UnitsOfMeasure' : 'nm',
                                                             'UnitsPerPixel' : str(scaleValueInNm)}))
        return (added, ScaleObj)
    
    @classmethod
    def GetBitmask(cls, ImageMin, ImageMax, TargetBpp):
        '''
        :param int ImageMin: Minimum value
        :param int ImageMax: Maximum value
        :param int TargetBpp: Desired bits-per-pixel after applying the bitmask,i.e. length of the bitmask
        :return: A bitmask which removes bits which do not contain information for integer values between min and max.'''
        
        # Figure out how many bits are required to encode the values between min and max
        ValueRange = ImageMax - ImageMin

        if(TargetBpp > 8):
            TargetBpp = int(math.ceil(math.log(ValueRange, 2)))

        # Figure out the left shift required to erase the top bits
        MaxUsefulHighBit = int(math.ceil(math.log(ImageMax, 2)))  # Floor because bits are numbered 0-N
        MinUsefulLowBit = (MaxUsefulHighBit - TargetBpp)

        if MinUsefulLowBit < 0:
            MinUsefulLowBit = 0

        # Build a value to AND with
        andValue = 0
        for i in range(MinUsefulLowBit, MaxUsefulHighBit):
            andValue = andValue + pow(2, i)
            
        return andValue
    
def _GetMinMaxCutoffs(listfilenames, histogramFullPath=None):
    MinCutoff = 0.0001
    MaxCutoff = 0.0001
    histogramObj = None
    if not histogramFullPath is None:
        if os.path.exists(histogramFullPath):
            histogramObj = Histogram.Load(histogramFullPath)

    if histogramObj is None:
        prettyoutput.Log("Collecting mosaic min/max data")
        Bpp = nornir_shared.images.GetImageBpp(listfilenames[0])
        histogramObj = image_stats.Histogram(listfilenames, Bpp=Bpp, Scale=.125, numBins=2048)

        if not histogramFullPath is None:
            histogramObj.Save(histogramFullPath)

    assert(not histogramObj is None)

    # I am willing to clip 1 pixel every hundred thousand on the dark side, and one every ten thousand on the light
    return histogramObj.AutoLevel(MinCutoff, MaxCutoff)
    
def _PlotHistogram(histogramFullPath, sectionNumber, minCutoff, maxCutoff):    
    HistogramImageFullPath = os.path.join(os.path.dirname(histogramFullPath), 'Histogram.png')
    ImageRemoved = RemoveOutdatedFile(histogramFullPath, HistogramImageFullPath)
    if ImageRemoved or not os.path.exists(HistogramImageFullPath):
        pool = nornir_pools.GetGlobalMultithreadingPool()
        pool.add_task(HistogramImageFullPath, plot.Histogram, histogramFullPath, HistogramImageFullPath, Title="Section %d Raw Data Pixel Intensity" % (sectionNumber), LinePosList=[minCutoff, maxCutoff])
        #plot.Histogram(histogramFullPath, HistogramImageFullPath, Title="Section %d Raw Data Pixel Intensity" % (sectionNumber), LinePosList=[minCutoff, maxCutoff])


class NornirTileset():
    
    Tile = collections.namedtuple("NornirTile", ('SourceImageFullPath', 'TargetImageFullPath', 'Position'))
    
    @property
    def MissingInputImages(self):
        return self._MissingInputImages
    
    @MissingInputImages.setter
    def MissingInputImages(self, value):
        self._MissingInputImages = value
    
    @property
    def ImageMoveRequired(self):
        if self._ImageMoveRequired is None:
            self._ImageMoveRequired = self._IsImageMoveRequired()
        return self._ImageMoveRequired
    
    def _IsImageMoveRequired(self):
        for t in self._tiles:
            if t.SourceImageFullPath != t.TargetImageFullPath:
                return True
            
        return False
    
    @property
    def ImageConversionRequired(self):
        if self._ImageConversionRequired is None:
            self._ImageConversionRequired = self._IsImageConversionRequired()
            
        return self._ImageConversionRequired
    
    def _IsImageConversionRequired(self):
        '''True if the extensions do not match'''
        for t in self._tiles:
            [Unused, SourceImageExt] = os.path.splitext(t.SourceImageFullPath)
            [Unused, TargetImageExt] = os.path.splitext(t.TargetImageFullPath) 
            if SourceImageExt.lower() != TargetImageExt.lower():
                return True
    
    def AddTile(self, tile):
        self._tiles.append(tile)
        self._ImageMoveRequired = None
        self._ImageConversionRequired = None
    
    @property
    def SourceImagesFullPaths(self):
        imagePaths = []
        for t in self._tiles:
            imagePaths.append(t.SourceImageFullPath)
            
        return imagePaths
          
    @property 
    def Tiles(self):
        return self._tiles
    
    def GetSourceToMissingTargetMap(self):
        ''':return: A dictionary mapping source image paths to missing target image paths'''
        
        SourceToTargetMap = {}
        for t in self._tiles:
            if os.path.exists(t.SourceImageFullPath) and not os.path.exists(t.TargetImageFullPath):
                SourceToTargetMap[t.SourceImageFullPath] = t.TargetImageFullPath
                
        return SourceToTargetMap
                
    def RemoveStaleTilesFromOutputDir(self, SupertilePath):
        for t in self._tiles:
            if not os.path.exists(t.SourceImageFullPath):
                RemoveOutdatedFile(t.SourceImageFullPath, SupertilePath)
                RemoveOutdatedFile(t.SourceImageFullPath, t.TargetImageFullPath)
    
    def GetPositionsForTargets(self):
        positionMap = {}
        for t in self._tiles:
            if os.path.exists(t.TargetImageFullPath):
                positionMap[t.TargetImageFullPath] = t.Position
            
        return positionMap
        
    def __init__(self, OutputImageExt):
        self._tiles = []
        self._MissingInputImages = False #True if some of the IDocImages are missing from the disk
        self._ImageMoveRequired = False #True if there are images that can be moved
        self._ImageConversionRequired = False #True if there are images that need to be converted
        self._OutputImageExt = OutputImageExt
                
        
    @classmethod
    def CreateTilesFromIDocTileData(cls, tiles, InputTileDir, OutputTileDir, OutputImageExt):
        ''' 
        :param tiles IDocTileData: List of tiles to build dictionaries from
        '''
        
        #SerialEM begins numbering file names from zero.  So we will too. 
        ImageNumber = -1
        
        obj = NornirTileset(OutputImageExt)
        
        for tile in tiles:

            [ImageRoot, ImageExt] = os.path.splitext(tile.Image)

            ImageExt = ImageExt.strip('.')
            ImageExt = ImageExt.lower()
            ImageNumber = ImageNumber + 1

            SourceImageFullPath = os.path.join(InputTileDir, tile.Image)
            if not os.path.exists(SourceImageFullPath):
                prettyoutput.Log("Could not locate import image: " + SourceImageFullPath)
                obj.MissingInputImage = True
                continue
            
            # I rename the converted image because I haven't checked how robust viking is with non-numbered images.  I'm 99% sure it can handle it, but I don't want to test now.
            ConvertedImageName = (nornir_buildmanager.templates.Current.TileCoordFormat % ImageNumber) + '.' + OutputImageExt
            TargetImageFullPath = os.path.join(OutputTileDir, ConvertedImageName)
            
            obj.AddTile(NornirTileset.Tile(SourceImageFullPath, TargetImageFullPath, Position=tile.PieceCoordinates[0:2]))
        
        return obj


def AddIdocNode(containerObj, idocFullPath, idocObj, logger):

    # Copy the idoc file to the output directory
    idocPath = os.path.basename(idocFullPath)
    IDocNodeObj = DataNode(Path=idocPath, attrib={'Name' : 'IDoc'})
    containerObj.RemoveOldChildrenByAttrib('Data', 'Name', 'IDoc')
    [added, IDocNodeObj] = containerObj.UpdateOrAddChildByAttrib(IDocNodeObj, 'Name')

    CopiedFileFullPath = os.path.join(containerObj.FullPath, idocPath)
    if not os.path.exists(CopiedFileFullPath):
        if not os.path.exists(containerObj.FullPath):
            os.makedirs(containerObj.FullPath)
        shutil.copyfile(idocFullPath, CopiedFileFullPath)

    # Copy over attributes from the idoc
    for k in idocObj.__dict__.keys():
        v = idocObj.__dict__[k]
        if k[0] == '_':
            continue

        if isinstance(v, list):
            continue

        setattr(IDocNodeObj, k, v)
#        if isinstance(v,str):
#            IDocNodeObj.attrib[k] = v
#        elif isinstance(v,list):
#
#            continue
#        else:
#            IDocNodeObj.attrib[k] = '%g' % v

    # Read the first tile obj, copy over common attributes
    assert(len(idocObj.tiles) > 0)
    tile = idocObj.tiles[0]

    for k in tile.__dict__.keys():
        v = tile.__dict__[k]

        if k[0] == '_':
            continue

        if isinstance(v, list):
            continue

        if k == 'Defocus':
            continue

        setattr(IDocNodeObj, k, v)

    return added


def TryAddNotes(containerObj, InputPath, logger):
    NotesFiles = glob.glob(os.path.join(InputPath, '*notes*.*'))
    NotesAdded = False
    if len(NotesFiles) > 0:
        for filename in NotesFiles:
            try:
                from xml.sax.saxutils import escape

                NotesFilename = os.path.basename(filename)
                CopiedNotesFullPath = os.path.join(containerObj.FullPath, NotesFilename)
                if not os.path.exists(CopiedNotesFullPath):
                    if not os.path.exists(containerObj.FullPath):
                        os.makedirs(containerObj.FullPath)
                    shutil.copyfile(filename, CopiedNotesFullPath)
                    NotesAdded = True

                with open(filename, 'r') as f:
                    notesTxt = f.read()
                    [base, ext] = os.path.splitext(filename)
                    encoding = "utf-8"
                    ext = ext.lower()
                    notesTxt = notesTxt.encode(encoding)

                    notesTxt = notesTxt.replace('\0', '')

                    if len(notesTxt) > 0:
                        # XMLnotesTxt = notesTxt
                        # notesTxt = notesTxt.encode('utf-8')
                        XMLnotesTxt = escape(notesTxt)

                        # Create a Notes node to save the notes into
                        NotesNodeObj = NotesNode(Text=XMLnotesTxt, SourceFilename=NotesFilename)
                        containerObj.RemoveOldChildrenByAttrib('Notes', 'SourceFilename', NotesFilename)
                        [added, NotesNodeObj] = containerObj.UpdateOrAddChildByAttrib(NotesNodeObj, 'SourceFilename')

                        if added:
                            # Try to copy the notes to the output dir if we created a node
                            if not os.path.exists(CopiedNotesFullPath):
                                shutil.copyfile(filename, CopiedNotesFullPath)

                        NotesNodeObj.text = XMLnotesTxt
                        NotesNodeObj.encoding = encoding

                        NotesAdded = NotesAdded or added

            except:
                (etype, evalue, etraceback) = sys.exc_info()
                prettyoutput.Log("Attempt to include notes from " + filename + " failed.\n" + evalue.message)
                prettyoutput.Log(etraceback)

    return NotesAdded


def TryAddLogs(containerObj, InputPath, logger):
    '''Copy log files to output directories, and store select meta-data in the containerObj if it exists'''
    LogsFiles = glob.glob(os.path.join(InputPath, '*.log'))
    LogsAdded = False
    if len(LogsFiles) > 0:
        for filename in LogsFiles:

            NotesFilename = os.path.basename(filename)
            CopiedLogsFullPath = os.path.join(containerObj.FullPath, NotesFilename)
            if not os.path.exists(CopiedLogsFullPath):
                if not os.path.exists(containerObj.FullPath):
                    os.makedirs(containerObj.FullPath)
                shutil.copyfile(filename, CopiedLogsFullPath)
                LogsAdded = True

            # OK, try to parse the logs
            try:
                LogData = SerialEMLog.Load(filename)
                if LogData is None:
                    pass

                # Create a Notes node to save the logs into
                LogNodeObj = DataNode(Path=NotesFilename, attrib={'Name':'Log'})
                containerObj.RemoveOldChildrenByAttrib('Data', 'Name', 'Log')
                [added, LogNodeObj] = containerObj.UpdateOrAddChildByAttrib(LogNodeObj, 'Name')
                LogsAdded = LogsAdded or added
                LogNodeObj.AverageTileTime = '%g' % LogData.AverageTileTime
                LogNodeObj.AverageTileDrift = '%g' % LogData.AverageTileDrift
                LogNodeObj.CaptureTime = '%g' % (LogData.MontageEnd - LogData.MontageStart)

            except:
                (etype, evalue, etraceback) = sys.exc_info()
                prettyoutput.Log("Attempt to include logs from " + filename + " failed.\n" + evalue.message)
                prettyoutput.Log(str(etraceback))

    return LogsAdded



class IDocTileData():



    def __init__(self, ImageName):
        '''Populate all known SerialEM Idoc meta-data'''
        self.Image = ImageName  # Name of the image
        self.TiltAngle = None
        self.PieceCoordinates = None
        self.StagePosition = None
        self.Intensity = None
        self.ExposureDose = None
        self.SpotSize = None
        self.Defocus = None
        self.ImageShift = None
        self.RotationAngle = None
        self.ExposureTime = None
        self.MinMaxMean = None
        self.TargetDefocus = None

    def __str__(self):
        return self.Image


class IDoc():
    '''Class that parses a SerialEM idoc file'''

    @property
    def NumTiles(self):
        return len(self.tiles)

    def __init__(self):
        self.DataMode = None
        self.PixelSpacing = None
        self.ImageSize = None
        self.tiles = []
        pass
    
    def GetImageBpp(self):
        ''':return: Bits per pixel if specified in the IDoc, otherwise None'''
        ImageBpp = None
        if (hasattr(self, 'DataMode')):
            if self.DataMode == 0:
                ImageBpp = 8
            elif self.DataMode == 1:
                ImageBpp = 16
            elif self.DataMode == 6:
                ImageBpp = 16
        
        return ImageBpp

    @classmethod
    def Load(cls, idocfullPath):
        assert(os.path.exists(idocfullPath))

        with open(idocfullPath, 'r') as hIDoc:
            idocText = hIDoc.read()

            obj = IDoc()

            imageStartIndicies = [m.start for m in re.finditer('\[Image', idocText)]
            NumImages = len(imageStartIndicies)

            lines = idocText.split('\n')

            TileData = None  # Set to the last image name we've read in, if None we are reading montage properties

            for iLine in range(0, len(lines)):
                line = lines[iLine]
                line = line.strip()
                line = line.strip('[]')
                parts = line.split('=')
                if(len(parts) <= 1):
                    continue

                attribute = parts[0].strip()
                # attribute = attribute.lower()



                # If we find an image tag, create a new tiledata
                if(attribute == 'Image'):
                    imageFilename = parts[1].strip()
                    TileData = IDocTileData(imageFilename)
                    obj.tiles.append(TileData)
                else:
                    value = None
                    if(len(parts) > 1):
                        values = parts[1].split()

                        vTemp = values[0].strip()
                        if vTemp[0].isdigit() or vTemp[0] == '-':


                            # Find out how many attributes we have.
                            # Try to convert to ints, then to float
                            ConvertedValues = []
                            try:
                                for v in values:
                                    convVal = int(v.strip())
                                    ConvertedValues.append(convVal)
                            except ValueError:
                                
                                try:
                                    for v in values:
                                        convVal = float(v.strip())
                                        ConvertedValues.append(convVal)
                                except ValueError:
                                    convVal = parts[1]
                                    

                            values = ConvertedValues
                            if len(values) == 1:
                                value = values[0]
                            else:
                                value = values

                    if not value is None:
                        if TileData is None:
                            obj.__dict__[attribute] = value
                        else:
                            TileData.__dict__[attribute] = value

            return obj

        return None


class LogTileData():
    '''Data for each individual tile in a capture'''

    @property
    def totalTime(self):
        '''Total time required to capture the file, based on interval between DoNextPiece calls in the log'''
        if self.endTime is None:
            return None

        return self.endTime - self.startTime

    @property
    def dwellTime(self):
        '''Total time required to acquire the tile after the stage stopped moving'''
        if self.stageStopTime is None:
            return None

        if self.endTime is None:
            return None

        return self.endTime - self.stageStopTime

    @property
    def settleTime(self):
        '''Total time required to for the first drift measurement below threshold after the stage stopped moving'''
        if len(self.driftStamps) == 0:
            return None

        if self.endTime is None:
            return None

        return self.endTime - self.driftStamps[-1]

    @property
    def drift(self):

        if len(self.driftStamps) > 0:
            (time, drift) = self.driftStamps[-1]
            return drift

        return None


    def __str__(self):
        text = ""
        if not self.number is None:
            text = str(self.number) + ": "
        if not self.totalTime is None:
            text = text + "%.1f" % self.totalTime
        if len(self.driftStamps) > 0:
            text = text + " %.2f " % self.drift
            if not self.driftUnits is None:
                text = text + " " + self.driftUnits

        return text

    def __init__(self, startTime):
        self.startTime = startTime  # Time when DoNextPiece was logged to begin this tile
        self.endTime = None  # Time when DoNextPiece was logged to start the next tile

        self.stageStopTime = None  # Time when the stage stopped moving

        self.driftStamps = []  # Contains tuples of time after stage move completion and measured drift
        self.settleTime = None  # Time required to capture the tile after the stage stopped moving.
        self.number = None  # The tile number in the capture
        self.driftUnits = None  # nm/sec
        self.coordinates = None

class SerialEMLog(object):

    @classmethod
    def __ObjVersion(cls):
        '''Used for knowing when to ignore a pickled file'''

        # Version 2 fixes missing tile drift times for the first tile in a hemisphere
        return 2

    @property
    def TotalTime(self):
        total = self.MontageEnd - self.MontageStart
        return total

    @property
    def AverageTileTime(self):
        total = 0.0
        for t in self.tileData.values():
            total = total + t.totalTime

        return total / len(self.tileData)

    @property
    def AverageTileDrift(self):
        total = 0.0
        count = 0
        for t in self.tileData.values():
            if t.drift is None:
                continue

            count = count + 1
            total = total + t.drift

        return total / count


    @property
    def FastestTileTime(self):
        '''Shortest time to capture a tile in seconds'''

        fastestTime = None
        for t in self.tileData.values():
            if not (t.dwellTime is None or t.drift is None):
                if fastestTime is None:
                    fastestTime = t.totalTime
                else:
                    fastestTime = min(fastestTime, t.totalTime)

        return fastestTime

    @property
    def MaxTileDrift(self):
        '''Largest drift for a tile in seconds'''
        maxdrift = 0
        for t in self.tileData.values():
            if not (t.dwellTime is None or t.drift is None):
                maxdrift = max(maxdrift, t.driftStamps[-1][1])

        return maxdrift

    @property
    def MinTileDrift(self):
        '''Largest drift for a tile in seconds'''
        mindrift = self.MaxTileDrift + 1
        for t in self.tileData.values():
            if not (t.dwellTime is None or t.drift is None):
                mindrift = min(mindrift, t.driftStamps[-1][1])

        return mindrift


    @property
    def NumTiles(self):
        NumTiles = 0
        for t in self.tileData.values():
            if not (t.dwellTime is None or t.drift is None):
                NumTiles = NumTiles + 1

        return NumTiles

    @property
    def Startup(self):
        return self._startup

    @property
    def Version(self):
        return self._version

    def __init__(self):
        self.tileData = {}  # The time required to capture each tile
        self._startup = None  # SerialEM program Startup time, if known
        self._version = None  # SerialEM version, if known
        self.PropertiesVersion = None  # Timestamp of properties file, if known
        self.MontageStart = None  # timestamp when acquire began
        self.MontageEnd = None  # timestamp when acquire ended

        self.__SerialEMLogVersion = SerialEMLog._SerialEMLog__ObjVersion()

    @classmethod
    def __PickleLoad(cls, logfullPath):

        obj = None
        picklePath = logfullPath + ".pickle"

        files.RemoveOutdatedFile(logfullPath, picklePath)

        if os.path.exists(picklePath):
            try:
                with open(picklePath, 'r') as filehandle:
                    obj = pickle.load(filehandle)

                    if obj.__SerialEMLogVersion != SerialEMLog._SerialEMLog__ObjVersion():
                        raise Exception("Version mismatch in pickled file: " + picklePath)
            except Exception as e:
                try:
                    os.remove(picklePath)
                except Exception as e:
                    pass

                obj = None

        return obj

    def __PickleSave(self, logfullPath):

        obj = None
        picklePath = logfullPath + ".pickle"

        try:
            with open(picklePath, 'w') as filehandle:
                pickle.dump(self, filehandle, protocol=0)
        except:
            try:
                os.remove(picklePath)
            except:
                pass

    @classmethod
    def Load(cls, logfullPath, usecache=True):
        '''Parses a SerialEM log file and extracts as much information as possible:
        '''

        # These are some samples of interesting lines this function looks for
        # Last update properties file: Sep 30, 2011
        # SerialEM Version 3.1.1a,  built Nov  9 2011  14:20:16
        # Started  4/23/2012  12:17:25
        # 2912.015: Montage Start
        # 2969.640: DoNextPiece Starting capture with stage move
        # 2980.703: BlankerProc finished stage move
        # 2984.078: SaveImage Saving image at 4 4,  file Z = 0
        # 2985.547: SaveImage Processing
        # 31197.078: Montage Done processing

        # 4839.203: Autofocus Start
        # Measured defocus = -0.80 microns                  drift = 1.57 nm/sec
        # 4849.797: Autofocus Done

        # Captures in SerialEM overlap.  Once the stage is in position the exposure is done,
        # then simultaneously the stage moves while the camera is read.  Generally the stage
        # finishes movement before the image is saved, but we should not count on this behaviour

        # Parsing these logs takes quite a while sometimes

        if usecache:
            obj = cls.__PickleLoad(logfullPath)

            if not obj is None:
                return obj


        Data = SerialEMLog()
        NextTile = None  # The tile we are currently moving the stage, focusing on, and setting up an aquisition for.
        AcquiredTile = None  # The tile which we have an image for, but has not been read from the CCD and saved to disk yet

        with open(logfullPath, 'r') as hLog:

            line = hLog.readline(512)

            lastDriftMeasure = None
            LastAutofocusStart = None
            LastValidTimestamp = None  # Used in case the log ends abruptly to populate MontageEnd value
            while len(line) > 0:
                line = line.strip()

                # print line

                # See if the entry starts with a timestamp
                entry = line
                timestamp = None

                if len(line) == 0:
                    line = hLog.readline(512)
                    continue

                if line[0].isdigit():
                    try:
                        (timestamp, entry) = line.split(':', 1)
                        timestamp = float(timestamp)
                    except ValueError:
                        pass
                entry = entry.strip()

                if entry.startswith('DoNextPiece'):

                    # The very first first stage move is not a capture, so don't save a tile.
                    # However the drift measurements are done on the first tile before we get a capture message.  We want to save those
                    if entry.find('capture') >= 0:
                        # We acquired the tile, prepare the next capture
                        if not NextTile is None:
                            NextTile.endTime = timestamp
                            #
                            assert (AcquiredTile is None)  # We are overwriting an unwritten tile if this assertion fails
                            AcquiredTile = NextTile
                            NextTile = None

                    NextTile = LogTileData(timestamp)

                elif entry.startswith('Autofocus Start'):
                    LastAutofocusStart = timestamp
                elif entry.startswith('Measured defocus'):
                    if not NextTile is None:

                        # The very first tile does not get a 'finished stage move' message.  Use the start of the autofocus to approximate completion of the stage move
                        if NextTile.stageStopTime is None:
                            NextTile.stageStopTime = LastAutofocusStart

                        iDrift = entry.find('drift')
                        if iDrift > -1:
                            DriftStr = entry[iDrift:]  # example: drift = 1.57 nm/sec
                            iEqual = DriftStr.find('=')
                            if iEqual > -1:
                                ValueStr = DriftStr[iEqual + 1:]  # example 1.57 nm/sec
                                ValueStr = ValueStr.strip()
                                (Value, Units) = ValueStr.split()
                                Units = Units.strip()
                                Value = Value.strip()
                                floatValue = float(Value)
                                driftTimestamp = LastAutofocusStart - NextTile.stageStopTime
                                NextTile.driftStamps.append((driftTimestamp, floatValue))
                                NextTile.driftUnits = Units
                elif entry.startswith('SaveImage Saving'):
                    assert(not AcquiredTile is None)  # We should have already recorded a capture event and populated AcquiredTile before seeing this line in the log
                    iEqual = line.find('=')
                    if iEqual > -1:
                        ValueStr = line[iEqual + 1:]  # example 1.57 nm/sec
                        ValueStr = ValueStr.strip()
                        FileNumber = int(ValueStr)
                        AcquiredTile.number = FileNumber

                        # Determine the position in the grid
                        iAt = line.find('at')
                        if iAt >= 0:
                            CoordString = line[iAt + 2:]
                            iComma = CoordString.find(',')
                            if iComma > 0:
                                CoordString = CoordString[:iComma]
                                Coords = CoordString.split()
                                X = int(Coords[0].strip())
                                Y = int(Coords[1].strip())
                                AcquiredTile.coordinates = (X, Y)


                        Data.tileData[AcquiredTile.number] = AcquiredTile
                        AcquiredTile = None

                elif entry.endswith('finished stage move'):
                    # Save the last tile
                    NextTile.stageStopTime = timestamp

                elif entry.startswith('Last update properties file'):
                    (entry, time) = line.split(':', 1)
                    time = time.strip()
                    Data.PropertiesVersion = time
                elif entry.startswith('SerialEM Version'):
                    Data._version = entry[len('SerialEM Version') + 1:].strip()
                elif entry.startswith('Montage Start'):
                    Data.MontageStart = timestamp
                elif entry.startswith('Montage Done'):
                    Data.MontageEnd = timestamp
                elif entry.startswith('Started'):
                    Data._startup = entry[len('Started') + 1:].strip()

                line = hLog.readline(512)

                if(not timestamp is None):
                    LastValidTimestamp = timestamp

            # If we did not find a MontageEnd value use the last valid timestamp
            if Data.MontageEnd is None and not LastValidTimestamp is None:
                Data.MontageEnd = LastValidTimestamp

        Data.__PickleSave(logfullPath)
        return Data


def __argToSerialEMLog(arg):
    Data = None
    if isinstance(arg, str):
        Data = SerialEMLog.Load(sys.argv[1])
    elif isinstance(arg, SerialEMLog):
        Data = arg
    else:
        raise Exception("Invalid argument type to PlotDrifGrid")

    return Data


def PlotDriftSettleTime(DataSource, OutputImageFile):
    '''Create a poly line plot showing how each tiles drift rate changed over time'''

    Data = __argToSerialEMLog(DataSource)

    lines = []
    maxdrift = None
    NumTiles = int(0)
    for t in Data.tileData.values():
        if not (t.dwellTime is None or t.drift is None):
            time = []
            drift = []

            for s in t.driftStamps:
                time.append(s[0])
                drift.append(s[1])

            maxdrift = max(maxdrift, t.driftStamps[-1][1])
            lines.append((time, drift))
            NumTiles = NumTiles + 1

    plot.PolyLine(lines, Title="Stage settle time, max drift %g" % maxdrift, XAxisLabel='Dwell time (sec)', YAxisLabel="Drift (nm/sec)", OutputFilename=OutputImageFile)

    return


def PlotDriftGrid(DataSource, OutputImageFile):

    Data = __argToSerialEMLog(DataSource)

    lines = []
    maxdrift = None
    NumTiles = int(0)
    fastestTime = None
    colors = ['black', 'blue', 'green', 'yellow', 'orange', 'red', 'purple']

    DriftGrid = []
    c = []
    for t in Data.tileData.values():
        if not (t.dwellTime is None or t.drift is None):
            time = []
            drift = []

            for s in t.driftStamps:
                time.append(s[0])
                drift.append(s[1])

            colorVal = 'black'
            numPoints = len(t.driftStamps)
            if  numPoints < len(colors):
                colorVal = colors[numPoints]

            c.append(colorVal)

            DriftGrid.append((t.coordinates[0], t.coordinates[1], pow(t.dwellTime, 2)))
            maxdrift = max(maxdrift, t.driftStamps[-1][1])
            if fastestTime is None:
                fastestTime = t.totalTime
            else:
                fastestTime = min(fastestTime, t.totalTime)

            lines.append((time, drift))
            NumTiles = NumTiles + 1

#    print "Fastest Capture: %g" % fastestTime
#

    #PlotHistogram.PolyLinePlot(lines, Title="Stage settle time, max drift %g" % maxdrift, XAxisLabel='Dwell time (sec)', YAxisLabel="Drift (nm/sec)", OutputFilename=None)

    x = []
    y = []
    s = []
    for d in DriftGrid:
        x.append(d[0])
        y.append(d[1])
        s.append(d[2])

    title = "Drift recorded at each capture position in mosaic\nradius = dwell time ^ 2, color = # of tries"

    plot.Scatter(x, y, s, c=c, Title=title, XAxisLabel='X', YAxisLabel='Y', OutputFilename=OutputImageFile)

    return


if __name__ == "__main__":

    datapath = sys.argv[1]

    basename = os.path.basename(datapath)
    (outfile, ext) = os.path.splitext(basename)
    outdir = os.path.dirname(datapath)

    Data = __argToSerialEMLog(datapath)

    dtime = datetime.timedelta(seconds=(Data.MontageEnd - Data.MontageStart))

    print "%d tiles" % len(Data.tileData)

    print "Average drift: %g nm/sec" % Data.AverageTileDrift
    print "Min drift: %g nm/sec" % Data.MinTileDrift
    print "Max drift: %g nm/sec" % Data.MaxTileDrift
    print "Average tile time: %g sec" % Data.AverageTileTime
    print "Fastest tile time: %g sec" % Data.FastestTileTime
    print "Total time: %s" % str(dtime)
    print "Total tiles: %d" % Data.NumTiles

    PlotDriftGrid(datapath, os.path.join(outdir, outfile + "_driftgrid.svg"))
    PlotDriftSettleTime(datapath, os.path.join(outdir, outfile + "_settletime.svg"))


