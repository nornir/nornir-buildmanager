<?xml version="1.0" encoding="utf-8"?>

<Pipelines xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                     xsi:schemaLocation="http://connectomes.utah.edu D:/Buildscript/Pipeline/Data/Buildscript.xsd"
                     xmlns:n0="http://connectomes.utah.edu/Buildscript/">
	<Arguments>
		<Argument flag="-to" action="store" dest="To" default="" help="E-Mail addresses for reports" nargs="*"/>
		<Argument flag="-cc" action="store" dest="CC" default="" help="E-Mail addresses for reports" nargs="*"/>
	</Arguments>

	<Pipeline Name="Prune" Description="Removes tiles without enough features for proper alignment.">
		<Arguments>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to process.  If omitted all sections are processed.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="False"/>
			<Argument flag="-Channels"  default="*" dest="ChannelsRegEx" type="str" help="Regular expression describing channels to include, * processes all channels" required="False"/>
			<Argument flag="-Threshold" dest="PruneThreshold" default="0" type="float" help="Texture complexity threshold" required="True"/>
			<Argument flag="-InputFilter" dest="InputFilter" default="Raw8" help="Filter to calculate complexity upon" required="False"/>
			<Argument flag="-Downsample" dest="Downsample" type="int" default="1" help="Tiles are downsampled by this factor before being scored" required="False"/>
			<Argument flag="-InputTransform" dest="InputTransform" default="Stage" help="Mosaic transform to prune.  The transform provides the list of tiles in the mosaic." required="False"/>
			<Argument flag="-OutputTransform" dest="OutputTransform" default="Prune" help="Name of output transform.  Contains tiles from input transform minus tiles below threshold." required="False"/>
			<Argument flag="-overlap" dest="Overlap" default="0.1" type="float" help="Percentage overlap between tiles, 0.0 to 1,0" required="False"/>
			
		</Arguments>
		
		<Iterate VariableName="section_node" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>

			<Iterate VariableName="ChannelNode" XPath="Channel">
				<RequireMatch Attribute="Name" RegEx="#ChannelsRegEx"/>
	
				<Select VariableName="Pyramid" XPath="Filter[@Name='#InputFilter']/TilePyramid"/>
				<PythonCall Function="tile.VerifyImages" TilePyramidNode="#Pyramid"/> 
	
				<Select VariableName="TransformNode" XPath="Transform[@Name='#InputTransform']"/>
				<PythonCall Function="registration.CompressTransforms" TransformNode="#TransformNode"/>
	
				<!-- Assign a number to each tile describing if there are interesting features to the image -->
				<Select VariableName="FilterNode" Root="ChannelNode" XPath="Filter[@Name='#InputFilter']"/>
				<PythonCall Function="pruneobj.PruneObj.CalculatePruneScores" Downsample="#Downsample" OutputFile="PruneScores">
					<Parameters>
						<Entry Name="Overlap" Value="#Overlap"/>
					</Parameters>
				</PythonCall>
	
				<!-- Remove tiles that are featureless from the mosaic -->
				<Select VariableName="PruneNode" Root="FilterNode" XPath="Prune[@Overlap='#Overlap']"/>
				<PythonCall Function="pruneobj.PruneObj.PruneMosaic" OutputTransformName="#OutputTransform">
					<Parameters>
						<Entry Name="Threshold" Value="#PruneThreshold"/>
					</Parameters>
				</PythonCall>
			</Iterate>
		</Iterate>  
	</Pipeline>

	<Pipeline Name="ShadeCorrect" Description="Brightfield microscopy shading correction.  Uses the max tile intensity across all tiles to determine the shading gradient.  Produces an inverted output filter with the shading subtracted.">
		<Arguments>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to process.  If omitted all sections are processed.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="False"/>			
			<Argument flag="-Channels"  default="*" dest="ChannelsRegEx" type="str" help="Regular expression describing channels to include, * processes all channels" required="False"/>
			<Argument flag="-Filters"  default="(?![M|m]ask)" dest="FiltersRegEx" type="str" help="Regular expression describing filters to include, * processes all filters" required="False"/> 
			<Argument flag="-OutputFilter" dest="OutputFilter" default="ShadingCorrected" help="Prefix added to output filters" required="False"/>
			<Argument flag="-Correction" dest="Correction" default="brightfield" help="Brightfield images have a light background with darker features.  Darkfield images have a dark background with light features." choices="brightfield,darkfield" required="True"/>
		</Arguments>
		<Iterate VariableName="section_node" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				<RequireMatch Attribute="Name" RegEx="#ChannelsRegEx"/>
				<Iterate VariableName="FilterNode" XPath="Filter">
					<RequireMatch Attribute="Name" RegEx="#FiltersRegEx"/>
	
					<Iterate VariableName="TilePyramidNode" XPath="TilePyramid">
						<PythonCall Function="tile.VerifyImages"/>
					</Iterate>
	
					<PythonCall Function="tile.CorrectTiles" FilterNode="#FilterNode" OutputFilterName="#OutputFilter" InvertSource="True" CorrectionType="#Correction"/>
				</Iterate>
			</Iterate>
		</Iterate>
	</Pipeline>

	<Pipeline Name="MigrateMultipleImageSets" Description="Migrate meta-data to latest version">
		<Iterate VariableName="FilterNode" XPath="Block/Section/Channel/Filter">
			<PythonCall Function="tile.MigrateMultipleImageSets">
			</PythonCall>
		</Iterate>
	</Pipeline>
	
	<Pipeline Name="MigrateToZeroOrigin" Description="Migrate mosaic transforms to zero origins">
		<Iterate VariableName="TransformNode" XPath="Block/Section/Channel/Transform">
			<RequireMatch Attribute="Name" RegEx="Grid"/>
			<PythonCall Function="registration.TransformNodeToZeroOrigin" transform_node="#TransformNode">
			</PythonCall>
		</Iterate>
	</Pipeline>

	<Pipeline Name="RenameFilter" Description="Renames a filter">
		<Arguments>
			<Argument flag="-InputFilter" dest="InputFilter" help="Old Filter name" required="True"/>
			<Argument flag="-OutputFilter" dest="NewName" help="New Filter name" required="True"/>
		</Arguments>
		<Iterate VariableName="FilterNode" XPath="Block/Section/Channel/Filter[@Name='#InputFilter']">
			<PythonCall Function="general.Rename" OldNode="#FilterNode" NewName="#NewName"/>
			<PythonCall Function="general.MovePath" Node="#FilterNode" NewPath="#NewName"/>
		</Iterate>

		<Iterate VariableName="FilterNode" XPath="Block/Section/Channel/Filter[@Name='#NewName']">
			<PythonCall Function="general.MovePath" Node="#FilterNode" NewPath="#NewName"/>
		</Iterate>
	</Pipeline>

	<Pipeline Name="RemoveDuplicateFilters" Description="For debugging.  Removes filters from meta-data that have duplicate names.">
		<Arguments>
			<Argument flag="-Attrib" dest="ChildAttrib" default="Name" help="Attrib to check for duplicates" required="False"/>
			<Argument flag="-ChildNode" dest="ChildNodeName" default="Filter_Link" help="Child node to check for duplicates" required="False"/> 
		</Arguments>
		<Iterate VariableName="ParentNode" XPath="Block/Section/Channel">
			<PythonCall Function="general.RemoveDuplicateLinks" ChildNodeName="#ChildNodeName" ChildAttrib="#ChildAttrib"/> 
		</Iterate>
	</Pipeline>

	<Pipeline Name="Histogram" Description="Calculates the histogram from all tiles in a mosaic">
		<Arguments>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to process.  If omitted all sections are processed.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="False"/>
			<Argument flag="-Channels"  default="*" dest="ChannelsRegEx" type="str" help="Regular expression describing channels to include, * processes all channels" required="False"/>
			<Argument flag="-Filters"  default="(?![M|m]ask)" dest="FiltersRegEx" type="str" help="Regular expression describing filters to include, * processes all filters" required="False"/>
			<Argument flag="-InputTransform" dest="InputTransform" default="Prune" help="The transform provided the list of tiles in the mosaic." required="True"/>
			<Argument flag="-Downsample" dest="Downsample" type="int" default="1" help="Use downsampled tiles for faster histogram calculation" required="False"/>
		</Arguments>
		<Iterate VariableName="section_node" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				<RequireMatch Attribute="Name" RegEx="#ChannelsRegEx"/>
	
				<Select VariableName="TransformNode" XPath="Transform[@Name='#InputTransform']"/>
	
				<Iterate VariableName="FilterNode" XPath="Filter">
					<RequireMatch Attribute="Name" RegEx="#FiltersRegEx"/>
	
					<!-- Calculate the intensity histogram for the entire mosaic -->
					<PythonCall Function="tile.HistogramFilter" FilterNode="#FilterNode" Downsample="#Downsample" TransformNode="#TransformNode">
					</PythonCall>
				</Iterate>
			</Iterate>
		</Iterate>
	</Pipeline>

	<Pipeline Name="AdjustContrast" Description="Creates a new filter with adjusted contrast.  The cutoffs can be adjusted within the meta-data by altering the AutoLevelHint element of the input filters volume.xml meta-data file.">
		<Arguments>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to process.  If omitted all sections are processed.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="False"/>
			<Argument flag="-Channels"  default="*" dest="ChannelsRegEx" type="str" help="Regular expression describing channels to include, * processes all channels" required="False"/>
			<Argument flag="-Gamma" dest="Gamma" help="Gamma value for intensity auto-level" required="False"/>
			<Argument flag="-MinCutoff" dest="MinCutoff" default="0.1" help="Min pixel intensity cutoff as a percentage, 0 to 100" required="False"/>
			<Argument flag="-MaxCutoff" dest="MaxCutoff" default="0.5" help="Max pixel intensity cutoff as a percentage, 0 to 100. Specifying '1' puts the cutoff at 99% of the maximum pixel intensity value." required="False"/>
			<Argument flag="-InputFilter" dest="InputFilter" default="Raw8" help="Filter to draw images from" required="True"/>
			<Argument flag="-OutputFilter" dest="OutputFilter" default="Leveled" help="Filter to draw images from" required="False"/>
			<Argument flag="-InputTransform" dest="InputTransform" default="Prune" help="Mosaic transform to prune.  The transform provides the list of tiles in the mosaic." required="True"/>
		</Arguments>

		<Iterate VariableName="section_node" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
					
				<RequireMatch Attribute="Name" RegEx="#ChannelsRegEx"/>
	
				<Select VariableName="TransformNode" XPath="Transform[@Name='#InputTransform']"/>
	
				<Select VariableName="FilterNode" XPath="Filter[@Name='#InputFilter']"/>
				<PythonCall Function="tile.AutolevelTiles" FilterNode="#FilterNode" OutputFilterName="#OutputFilter">
					<Parameters>
						<Entry Name="Gamma" Value="#Gamma"/> 
						<Entry Name="MinCutoff" Value="#MinCutoff"/> 
						<Entry Name="MaxCutoff" Value="#MaxCutoff"/> 
					</Parameters>
				</PythonCall>
	
				<Select VariableName="PyramidNode" Root="ChannelNode"  XPath="Filter[@Name='#OutputFilter']/TilePyramid"/>
				<PythonCall Function="tile.BuildTilePyramids"/>
			</Iterate>
		</Iterate>
	</Pipeline>

	<Pipeline Name="Mosaic" Description="Aligns tiles of a filter into a single mosaic.  Produces an assembled mosaic image.">
		<Arguments>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to process.  If omitted all sections are processed.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="False"/>
			<Argument flag="-Channels"  default="*" dest="ChannelsRegEx" type="str" help="Regular expression describing channels to include, * processes all channels" required="False"/>
			<Argument flag="-RegistrationDownsample" dest="Downsample" default="4" type="int" help="Downsample level to use for ir-tools" required="False"/>
			<Argument flag="-MaxOffset" dest="MaxOffset" default="0.5" type="float" help="Comma seperated list of downsample levels used for assembling output images" required="False"/>
			<Argument flag="-InputFilter" dest="InputFilter" default="Raw8" help="Filter to use for registration" required="True"/>
			<Argument flag="-InputTransform" dest="InputTransformName" default="Prune" help="Name of the input transform" required="False"/>
			<Argument flag="-OutputTransform" dest="OutputTransformName" default="Grid" help="Name of output transform." required="False"/>
		</Arguments>

		<Iterate VariableName="section_node" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				
				<RequireMatch Attribute="Name" RegEx="#ChannelsRegEx"/>
	
				<Select VariableName="TransformNode" XPath="Transform[@Name='#InputTransformName']"/>
				<Select VariableName="FilterNode" XPath="Filter[@Name='#InputFilter']"/>
				
				<!-- ir-translate, calculate translation for each tile into the greater mosaic -->
				<PythonCall Function="registration.TranslateTransform" TransformNode="#TransformNode" OutputTransform="Translated_#InputTransformName" FilterNode="#FilterNode" RegistrationDownsample="#Downsample">
					<Parameters>
						<Entry Name="MaxOffsetX" Value="#MaxOffset"/>
					</Parameters>
				</PythonCall>
	
				<!-- ir-refine-grid, lay a mesh over each tile and align points to overlapping tiles -->
				<Select VariableName="TranslatedTransformNode" Root="ChannelNode"  XPath="Transform[@Name='Translated_#InputTransformName']"/>
				<PythonCall Function="registration.CompressTransforms" TransformNode="#TranslatedTransformNode"/>
				<PythonCall Function="registration.GridTransform" OutputTransform="#OutputTransformName" TransformNode="#TranslatedTransformNode" FilterNode="#FilterNode" RegistrationDownsample="#Downsample">
					<Parameters>
						<Entry Name="MeshWidth" Value="8"/>
						<Entry Name="MeshHeight" Value="8"/>
						<Entry Name="Cell" Value="96"/>
						<Entry Name="Threshold" Value="0.5"/>
					</Parameters>
				</PythonCall>
	 
				<Select VariableName="RefinedTransformNode" Root="ChannelNode"  XPath="Transform[@Name='#OutputTransformName']"/>
				<PythonCall Function="registration.CompressTransforms" TransformNode="#RefinedTransformNode"/>
			</Iterate>
		</Iterate>
	</Pipeline>

	<Pipeline Name="Assemble" Description="Creates an assembled image from a transform and filter. Optionally creates a new channel for output.">
		<Arguments>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to process.  If omitted all sections are processed.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="False"/>
			<Argument flag="-Downsample" dest="Levels" default="1" help="Comma seperated list of downsample levels for assembling images.  If output is desired only one downsample level can be used." required="False"/>
			<Argument flag="-NoInterlace" dest="Interlace" action="store_false" default="True" help="Setting this flag skips the interlace step after assemble.  Interlaced images load faster on web pages, but are larger than non-interlaced images." required="False"/>
			<Argument flag="-Channels" dest="ChannelRegEx" default="*" help="Regular expression describing channels to be assembled" required="False"/>
			<Argument flag="-ChannelPrefix" dest="OutputChannelPrefix" default="" type="str" help="Create a new channel for the output with this prefix and the name of the input." required="False"/>
			<Argument flag="-Filters" dest="FilterRegEx" default="(?![M|m]ask)" help="Regular expression describing filters to be assembled" required="False"/>
			<Argument flag="-Transform" dest="TransformName" default="Grid" help="Directory to move assembled images to" required="False"/>
		</Arguments>
		<Iterate VariableName="section_node" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				
				<RequireMatch Attribute="Name" RegEx="#ChannelRegEx"/>
	
				<!-- Build a downsampled image of the mosaic -->
				<Select VariableName="TransformNode" XPath="Transform[@Name='#TransformName']"/>
	
				<Iterate VariableName="FilterNode" XPath="Filter">
					<RequireMatch Attribute="Name" RegEx="#FilterRegEx"/>
	
					<PythonCall Function="tile.AssembleTransform" OutputChannelPrefix="#OutputChannelPrefix" Interlace="#Interlace" Levels="#Levels">
						<Parameters>
							<Entry Name="feathering" Value="binary"/>
						</Parameters>
					</PythonCall>
				</Iterate>
			</Iterate>
		</Iterate>
	</Pipeline>

	<Pipeline Name="AssembleTiles" Description="Build small full-resolution tiles, usually 256x256, that allow regions of the mosaic to be rapidly loaded">
		<Arguments>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to process.  If omitted all sections are processed.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="False"/>
			<Argument flag="-Channels" dest="ChannelRegEx" default="*" help="Regular expression describing channels to be assembled" required="False"/>
			<Argument flag="-Filters" dest="FilterRegEx" default="(?![M|m]ask)" help="Regular expression describing filters to be assembled" required="False"/>
			<Argument flag="-Transform" dest="TransformName" default="Grid" help="Transform defining images into mosaic" required="False"/>
			<Argument flag="-Downsample" dest="Downsample" type="int" default="1" help="Comma seperated list of downsample levels for assembling output images" required="False"/>
		</Arguments>

		<Iterate VariableName="section_node" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				
				<RequireMatch Attribute="Name" RegEx="#ChannelRegEx"/>
	
				<Select VariableName="TransformNode" XPath="Transform[@Name='#TransformName']"/>
				<Iterate VariableName="FilterNode" XPath="Filter">
					<RequireMatch Attribute="Name" RegEx="#FilterRegEx"/>			
	
					<Select VariableName="PyramidNode" Root="FilterNode" XPath="TilePyramid"/>
					<PythonCall Function="tile.AssembleTileset"/>
	
					<Select VariableName="TileSetNode" Root="FilterNode" XPath="Tileset"/>
					<PythonCall Function="tile.BuildTilesetPyramid"/>
				</Iterate>
			</Iterate>
		</Iterate> 
	</Pipeline>

	<Pipeline Name="MosaicReport" Description="Generate a web page summarizing the output of 2D section mosaics.  Includes prune scores, contrast histograms, and assembled images if any.">
		<Arguments>
			<Argument flag="-PruneFilter" dest="PruneFilter" default="Raw8" help="Input filter passed to Prune pipeline" required="False"/>
			<Argument flag="-ContrastFilter" dest="ContrastFilter" default="Raw8" help="Input filter passed to Adjust Contrast pipeline" required="False"/>
			<Argument flag="-AssembleFilter" dest="AssembleFilter" default="Raw8" help="Input filter passed to Assemble or Mosaic pipeline" required="False"/>
			<Argument flag="-AssembleDownsample" dest="AssembleDownsample" type="int" default="1" help="Downsample level to build assembled image thumbnails from" required="False"/>
			<Argument flag="-Output" dest="OutputPath" type="str" default="ImageReport" help="Name of report html file" required="False"/>
		</Arguments>
		<Select VariableName="ReportingElement" XPath="Block"/>
		<PythonCall Function="reporting.GenerateTableReport"
     		    OutputFile="#OutputPath"
     		    RowXPath="Section"
     		    RowLabelAttrib="Number"
     		    MaxImageWidth="512"
     		    MaxImageHeight="512"
     		    ColumnXPaths="Channel/Filter[@Name='#AssembleFilter']/ImageSet/Level[@Downsample='#AssembleDownsample']/Image,Channel/Notes,Channel/Data,Channel/Filter[@Name='#ContrastFilter']/Histogram/Image,Channel/Filter[@Name='#PruneFilter']/Prune/Image" />

		<PythonCall Module="nornir_buildmanager.VolumeFinder" Function="EmailIndex" subject="Volume Report" to="#To" cc="#CC"/>
	</Pipeline>

	<!--
	
	<Pipeline Name="StosReport" Description="Generate a web page containing a summary of the alignments between sections in a 3D volume">
		<Arguments>
			<Argument flag="-StosGroup" dest="StosGroup" help="Stos group to pull images from" required="True"/>
		</Arguments>
		<Select VariableName="ReportingElement" XPath="Block/StosGroup[@Name='#StosGroup']"/>
		<PythonCall Function="reporting.GenerateTableReport"
     		    OutputFile="StosReport.html"
     		    RowXPath="SectionMappings"
     		    RowLabelAttrib="MappedSectionNumber"
     		    MaxImageWidth="512"
     		    MaxImageHeight="512"
     		    ColumnXPaths="Image,Transform" />

		<PythonCall Module="nornir_buildmanager.VolumeFinder" Function="EmailIndex" subject="Volume Report" to="#To" cc="#CC"/>
	</Pipeline>
	
	-->

	<Pipeline Name="CreateVikingXML"  Description="Create a vikingxml file for use in Viking"> 
		<Arguments>
			<Argument flag="-StosGroup" dest="StosGroup" help="Stos group to pull images from.  If not specified only unregistered mosaics are included." required="False"/>
			<Argument flag="-StosMap" dest="StosMap" help="Slice-to-slice mapping of transforms.  If not specified only unregistered mosaics are included." required="False"/>
			<Argument flag="-Host" dest="Host" help="Url of volume, overrides the about.xml settings" required="False"/>
			<Argument flag="-OutputFile" dest="OutputFile" help="Name of file to write .VikingXML is appended to name automatically" required="True"/>
		</Arguments>

		<PythonCall Function="vikingxml.CreateVikingXML" StosMapName="#StosMap" StosGroupName="#StosGroup"  Host="#Host" OutputFile="#OutputFile"/>
	</Pipeline>
	
	
	<Pipeline Name="Cleanup"  Description="Clean common errors from the volume meta-data"> 
		<Arguments> 
		</Arguments>
			<Iterate VariableName="FilterNode" XPath="Block/Section/Channel/Filter">
				<PythonCall Function="tile.VerifyAssembledImagePathIsCorrect" FilterNode="#FilterNode"/>
			</Iterate>
			<Iterate VariableName="ImageNode" XPath="Block/Section/Channel/Filter/ImageSet/Level/Image">
				<PythonCall Function="general.CleanNodeIfInvalid" node="#ImageNode"/>
			</Iterate>
			<Iterate VariableName="TransformNode" XPath="Block/StosGroup/SectionMappings/Transform">
				<PythonCall Function="block.ValidateSectionMappingTransformPipeline" stos_transform_node="#TransformNode"/>
			</Iterate>
			<Iterate VariableName="TransformNode" XPath="Block/Section/Channel/Transform">
				<PythonCall Function="general.CleanNodeIfInvalid" node="#TransformNode"/>
			</Iterate>
	</Pipeline>
	
	<Pipeline Name="SetPruneCutoff" Description="Set the prune threshold for a filter">
		<Arguments>
		    <Argument flag="-Value" dest="PruneVal" type="float" help="Prune threshold to set" required="True" default="0"/>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to edit.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="True"/>
			<Argument flag="-Channels" dest="ChannelRegEx" default="*" help="Regular expression describing channels to be edited" required="False"/>
			<Argument flag="-Filters" dest="FilterRegEx" default="*" help="Regular expression describing filters to be edited" required="False"/>
		</Arguments>
		
		<Iterate VariableName="SectionNode" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				<RequireMatch Attribute="Name" RegEx="#ChannelRegEx"/>
				
				<Iterate VariableName="FilterNode" XPath="Filter">
					<RequireMatch Attribute="Name" RegEx="#FilterRegEx"/>
					
					<Select VariableName="PruneNode" XPath="Prune"/>
					
					<PythonCall Function="setters.SetPruneThreshold" PruneNode="#PruneNode" Value="#PruneVal"/>
				</Iterate>
				
				<Iterate VariableName="FilterNode" XPath="Filter">
			    	<!-- This should be more refined to only unlock filters built upon the filter whose contrast has been changed -->
					<PythonCall Function="setters.SetFilterContrastLocked" FilterNode="#FilterNode" Locked="0"/>
				</Iterate>
			</Iterate>			
		</Iterate>
	</Pipeline>
	
	<Pipeline Name="SetContrast" Description="Set the contrast parameters for a filter">
		<Arguments>
		    <Argument flag="-Min" dest="MinValue" type="float" help="Min intensity value, set to 0 in output" required="False" default="NaN"/>
			<Argument flag="-Max" dest="MaxValue" type="float" help="Max intensity value, set to 1 in output" required="False" default="NaN"/>
			<Argument flag="-Gamma" dest="GammaValue" type="float" help="Gamma adjustment" required="False" default="NaN"/>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to edit.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="True"/>
			<Argument flag="-Channels" dest="ChannelRegEx" default="*" help="Regular expression describing channels to be edited" required="False"/>
			<Argument flag="-Filters" dest="FilterRegEx" default="*" help="Regular expression describing filters to be edited" required="False"/>
		</Arguments>
		
		<Iterate VariableName="SectionNode" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				<RequireMatch Attribute="Name" RegEx="#ChannelRegEx"/>
				
				<Iterate VariableName="FilterNode" XPath="Filter">
					<RequireMatch Attribute="Name" RegEx="#FilterRegEx"/>
					
					<Select VariableName="HistogramNode" XPath="Histogram"/>
					
					<PythonCall Function="setters.SetContrastRange" HistogramElement="#HistogramNode" 
					            MinValue="#MinValue" MaxValue="#MaxValue" GammaValue="#GammaValue"/>
					
				</Iterate>
				
				<Iterate VariableName="FilterNode" XPath="Filter">
				    <!-- This should be more refined to only unlock filters built upon the filter whose contrast has been changed -->
					<PythonCall Function="setters.SetFilterContrastLocked" FilterNode="#FilterNode" Locked="0"/>
				</Iterate>
			</Iterate>
		</Iterate>
	</Pipeline>
	
	<Pipeline Name="SetFilterLock" Description="Toggle the locked flag for a filter.  Locked filters will not have images recalculated.">
		<Arguments>
		    <Argument flag="-Locked" dest="Locked" type="int" help="Lock value, 0 = unlocked, 1 = locked" required="True"/>
			<Argument flag="-Sections" dest="Sections" type="NumberList" help="Section numbers to edit.  Values are seperated with commas and ranges are indicated by hyphens. Ex: '1,3,5-7' == [1,3,5,6,7]" required="True"/>
			<Argument flag="-Channels" dest="ChannelRegEx" default="*" help="Regular expression describing channels to be edited" required="False"/>
			<Argument flag="-Filters" dest="FilterRegEx" default="*" help="Regular expression describing filters to be edited" required="False"/>
		</Arguments>
		
		<Iterate VariableName="SectionNode" XPath="Block/Section">
			<RequireSetMembership Attribute="Number" List="#Sections"/>
			
			<Iterate VariableName="ChannelNode" XPath="Channel">
				<RequireMatch Attribute="Name" RegEx="#ChannelRegEx"/>
				
				<Iterate VariableName="FilterNode" XPath="Filter">
					<RequireMatch Attribute="Name" RegEx="#FilterRegEx"/> 
					
					<PythonCall Function="setters.SetFilterContrastLocked" FilterNode="#FilterNode" Locked="#Locked"/>
				</Iterate>
			</Iterate>
		</Iterate>
	</Pipeline>
	

	<Pipeline Name="CreateBlobFilter" Description="Create a blob filter from an input filter.  Blobbing can make brute slice-to-slice alignment more reliable for downsampled mosaics with fine textures.">
		<Arguments>
			<Argument flag="-Channels" dest="ChannelRegEx" default="*" help="Regular expression describing channels to be assembled" required="False"/>
			<Argument flag="-InputFilter" dest="InputFilter" default="Leveled" help="Name of filter to create blob filter for" required="True"/>
			<Argument flag="-Levels" dest="BlobDownsampleLevels" default="1" help="Downsample levels to be blobbed" required="False"/>
			<Argument flag="-Radius" dest="BlobRadius" default="9" help="Radius to calculate variance within" required="False"/>
			<Argument flag="-Median" dest="BlobMedian" default="7" help="Median filter radius for input" required="False"/>
			<Argument flag="-Max"    dest="BlobMax" default="3" help="Max variance before cropping" required="False"/>
			<Argument flag="-OutputFilter" dest="OutputFilterName" default="Blob" help="Prefix added to created filters" required="False"/>
		</Arguments>

		<Iterate VariableName="ChannelNode" XPath="Block/Section/Channel">
			<RequireMatch Attribute="Name" RegEx="#ChannelRegEx"/>

			<Select VariableName="FilterNode" XPath="Filter[@Name='#InputFilter']"/>

			<PythonCall Function="channel.CreateBlobFilter" Levels="#BlobDownsampleLevels" InputFilter="#FilterNode" OutputFilterName="#OutputFilterName">
				<Parameters>
					<Entry Name="r" Value="#BlobRadius"/>
					<Entry Name="median" Value="#BlobMedian"/>
					<Entry Name="max" Value="#BlobMax"/>
				</Parameters>
			</PythonCall>
		</Iterate>
	</Pipeline>

	<Pipeline Name="AlignSections" Description="Performs slice to slice alignment from scratch to produce an initial 3D volume.  After alignment the best alignment results are selected to create a final stosmap.">
		<Arguments>
			<Argument flag="-Center" dest="Center" type="int" help="Center section of the volume.  Defaults to center if unspecified.  The first run center is saved in meta-data and re-used on later runs." required="False"/>
			<Argument flag="-NumAdjacentSections"  default="1" dest="NumAdjacentSections" type="int" help="Number of adjacent sections to attempt registration with." required="False"/>
			<Argument flag="-Channels"  default="*" dest="ChannelsRegEx" type="str" help="Regular expression describing channels to be aligned" required="False"/>
			<Argument flag="-Filters"  default="(?![M|m]ask)" dest="FiltersRegEx" type="str" help="Regular expression describing filters to be aligned" required="False"/>
			<Argument flag="-StosUseMasks"  default="True" dest="UseMasks" type="bool" help="Use masks for images if they are available.  Masked areas are replaced with random noise for alignment purposes." required="False"/>
			<Argument flag="-Downsample"  default="1" dest="StosBruteDownsample" type="int" help="Amount to downsample input images before attempting alignment.  Images are padded to the next power of two for the FFT.  Large images, roughly greater than 2048x2048, can be very slow." required="True"/>
			<Argument flag="-OutputStosMap"  default="PotentialRegistrationChain" dest="OutputStosMap" type="str" help="Name assigned to generated stos map." required="False"/>		
		</Arguments>

		<Select VariableName="BlockNode" XPath="Block"/>
		<PythonCall Function="block.CreateSectionToSectionMapping" OutputStosMapName="#OutputStosMap" >
			<Parameters>
				<Entry Name="NumAdjacentSections" Value="#NumAdjacentSections"/>
				<Entry Name="CenterSection" Value="#Center"/>
			</Parameters>
		</PythonCall>

		<Select Root="BlockNode" VariableName="StosMapNodeObj" XPath="StosMap[@Name='#OutputStosMap']"/>
		<Iterate Root="StosMapNodeObj" VariableName="MappingNode" XPath="Mapping">
			<PythonCall Function="block.StosBrute" Root="BlockNode" OutputGroup="StosBrute#StosBruteDownsample" ChannelsRegEx="#ChannelsRegEx" FiltersRegEx="#FiltersRegEx">
				<Parameters>
					<Entry Name="Downsample" Value="#StosBruteDownsample"/>
					<Entry Name="refine"/>
					<Entry Name="regularize"/>
				</Parameters>
			</PythonCall>
		</Iterate>
	</Pipeline>
	
	<Pipeline Name="AssembleStosOverlays" Description="Performs slice to slice alignment from scratch to produce an initial 3D volume.  After alignment the best alignment results are selected to create a final stosmap.">
		<Arguments>
			<Argument flag="-StosGroup"  default="StosBrute" dest="StosGroup" type="str" help="Stos group to assemble" required="True"/>
			<Argument flag="-Downsample" dest="InputDownsample" type="int" help="Downsample level to assemble" required="True"/>
			<Argument flag="-StosMap"  default="FinalStosMap" dest="StosMap" type="str" help="Name assigned to generated stos map." required="True"/>
		</Arguments>

		<Select VariableName="BlockNode" XPath="Block"/>
		<Select VariableName="GroupNodeObj" Root="BlockNode" XPath="StosGroup[@Name='#StosGroup#InputDownsample']"/>
		<Select Root="BlockNode" VariableName="StosMapNodeObj" XPath="StosMap[@Name='#StosMap']"/>
		<PythonCall Function="block.AssembleStosOverlays" GroupNode="#GroupNodeObj" StosMapNode="#StosMapNodeObj"/>
	</Pipeline>
	
	<Pipeline Name="SelectBestRegistrationChain" Description="Create a new registration chain by examining the stos overlays produced by AssembleStosOverlays.  If two registrations are possible for a section the overlay with the most overlap is chosen.">
		<Arguments>
			<Argument flag="-StosGroup"  default="StosBrute" dest="StosGroup" type="str" help="Stos group to assemble" required="True"/>
			<Argument flag="-Downsample" dest="InputDownsample" type="int" help="Downsample level to assemble" required="True"/>
			<Argument flag="-InputStosMap"  default="PotentialRegistrationChain" dest="InputStosMap" type="str" help="Name assigned to generated stos map." required="True"/>
			<Argument flag="-OutputStosMap"  default="FinalStosMap" dest="OutputStosMap" type="str" help="Name assigned to generated stos map." required="False"/>
		</Arguments>

		<Select VariableName="BlockNode" XPath="Block"/>
		<Select VariableName="GroupNodeObj" Root="BlockNode" XPath="StosGroup[@Name='#StosGroup#InputDownsample']"/>
		<Select Root="BlockNode" VariableName="StosMapNodeObj" XPath="StosMap[@Name='#InputStosMap']"/>
		<PythonCall Function="block.SelectBestRegistrationChain" InputGroupNode="#GroupNodeObj" StosMapNode="#StosMapNodeObj" OutputStosMapName="#OutputStosMap"/>
	</Pipeline>
	
	
	<Pipeline Name="RefineSectionAlignment" Description="Refines slice-to-slice alignment at the given downsample level.  This pipeline is often used iteratively at higher and higher resolutions to improve registration quality.">
		<Arguments>
			<Argument flag="-SectionMap"  default="FinalStosMap" dest="StosMap" type="str" help="Map describing which sections register to each other" required="False"/>
			<Argument flag="-InputGroup"  default="StosBrute" dest="InputGroup" type="str" help="Map describing which sections register to each other" required="False"/>
			<Argument flag="-InputDownsample" dest="InputDownsample" type="int" help="Downsample level to use for input" required="True"/>
			<Argument flag="-OutputGroup"  default="StosGrid" dest="OutputGroup" type="str" help="Name of output group" required="False"/>
			<Argument flag="-OutputDownsample" dest="OutputDownsample" type="int" help="Downsample level to use for refinement" required="True"/>
			<Argument flag="-Filters"  default="(?![M|m]ask)" dest="FiltersRegEx" type="str" help="Regular expression describing filters to be aligned" required="False"/>
			<Argument flag="-StosUseMasks"  default="True" dest="UseMasks" type="bool" help="Image set to use as mask" required="False"/>
		</Arguments>

		<Select VariableName="BlockNode" XPath="Block"/>
		<Select Root="BlockNode" VariableName="StosMapNodeObj" XPath="StosMap[@Name='#StosMap']"/>

		<Select VariableName="InputGroupNode" Root="BlockNode" XPath="StosGroup[@Name='#InputGroup#InputDownsample']"/>
		<Iterate Root="StosMapNodeObj" VariableName="MappingNodeObj"  XPath="Mapping">
			<PythonCall Function="block.StosGrid" MappingNode="#MappingNodeObj" OutputStosGroup="#OutputGroup#OutputDownsample" Downsample="#OutputDownsample"
      												   ControlFilterPattern="#FiltersRegEx" MappedFilterPattern="#FiltersRegEx">
				<Parameters>
					<Entry Name="grid_spacing" Value="128"/>
					<Entry Name="neighborhood" Value="128"/>
					<Entry Name="it" Value="10"/>
					<Entry Name="fft" Value="2 0.25"/> 
					<Entry Name="displacement_threshold" Value="0.1"/>
				</Parameters>
			</PythonCall>
		</Iterate>
	</Pipeline>

	<Pipeline Name="ScaleVolumeTransforms" Description="Scales a stos group to use a different downsample level.  Useful for producing full-resolution output after generating transforms using downsampled images.">
		<Arguments>
			<Argument flag="-InputGroup" default="SliceToVolume" dest="ScaleGroupName" type="str" required="False" help="Name of stos group to scale" />
			<Argument flag="-InputDownsample" dest="ScaleInputDownsample" type="int" help="Downsample level of input stosgroup" required="True"/>
			<Argument flag="-OutputDownsample"  default="1" dest="ScaleOutputDownsample" type="int" help="Downsample level of output" required="False"/>
		</Arguments>

		<Iterate VariableName="BlockNode" XPath="Block">
			<Select VariableName="StosGroupNode" Root="BlockNode" XPath="StosGroup[@Name='#ScaleGroupName#ScaleInputDownsample']"/> 
			<PythonCall Function="block.ScaleStosGroup"
	   			   InputStosGroupNode="#StosGroupNode"
	               OutputDownsample="#ScaleOutputDownsample"
	               OutputGroupName="#ScaleGroupName#ScaleOutputDownsample"/>   
		</Iterate>
	</Pipeline>

	<Pipeline Name="SliceToVolume"  Description="Created a group of slice-to-volume transforms from a group of slice-to-slice transforms">
		<Arguments>
			<Argument flag="-InputDownsample" dest="StovDownsample" default="16" type="int" help="Downsample level to use for SliceToVolume" required="False"/>
			<Argument flag="-InputGroup"  default="StosGrid" dest="StovInputGroup" type="str" help="Map describing which sections register to each other" required="True"/>
			<Argument flag="-OutputGroup"  default="SliceToVolume" dest="StovOutputGroupName" type="str" help="Name of output group" required="False"/>
			<Argument flag="-InputMap"  default="FinalStosMap" dest="InputMap" type="str" help="Name of output group" required="False"/>
		</Arguments>
		<Iterate VariableName="BlockNode" XPath="Block"> 
			<Iterate VariableName="StosMapNode" XPath="StosMap[@Name='#InputMap']">
				<Iterate VariableName="StosGroupNode" Root="BlockNode" XPath="StosGroup[@Name='#StovInputGroup#StovDownsample']">
					<PythonCall Function="block.BuildSliceToVolumeTransforms"  OutputMap="#StovOutputGroupName" OutputGroup="#StovOutputGroupName#StovDownsample">
					</PythonCall>
				</Iterate>
			</Iterate> 
		</Iterate>
	</Pipeline>

	<!--
	
	<Pipeline Name="SliceToVolumeZeroTest"  Description="Created a group of slice-to-volume transforms from a group of slice-to-slice transforms">
		<Arguments>
			<Argument flag="-InputDownsample" dest="StovDownsample" default="16" type="int" help="Downsample level to use for SliceToVolume" required="False"/>
			<Argument flag="-InputGroup"  default="StosGrid" dest="StovInputGroup" type="str" help="Map describing which sections register to each other" required="True"/>
			<Argument flag="-OutputGroup"  default="SliceToVolume" dest="StovOutputGroupName" type="str" help="Name of output group" required="False"/>
			<Argument flag="-InputMap"  default="FinalStosMap" dest="InputMap" type="str" help="Name of output group" required="False"/>
		</Arguments>
		<Iterate VariableName="BlockNode" XPath="Block"> 
			<Iterate VariableName="StosMapNode" XPath="StosMap[@Name='#InputMap']">
				<Iterate VariableName="StosGroupNode" Root="BlockNode" XPath="StosGroup[@Name='#StovOutputGroupName#StovDownsample']">
					<PythonCall Function="block.TranslateVolumeToZeroOrigin">
					</PythonCall>
				</Iterate>
			</Iterate>
		
		</Iterate>
	</Pipeline>
	-->

	-->

	<Pipeline Name="VolumeImage" Description="Produces an assembled image for transforms in a stos group.  If the transforms are slice-to-volume transforms the output should be registered into a volume.  Note that using this function requires assembled images to exist at full resolution.  If these do not exist see the MosaicToVolume pipeline.">
		<Arguments>
			<Argument flag="-InputGroup" default="SliceToVolume" dest="VolumeImageGroupName" type="str" required="False" help="Name of stos group to create scaled version of, default = SliceToVolume"/>
			<Argument flag="-InputDownsample" default="1" dest="VolumeImageDownsample" type="int" help="Downsample level of input stosgroup, default = 1"/>
		</Arguments>
		<Iterate VariableName="BlockNode" XPath="Block"> 
			<!-- <Iterate VariableName="StosMapNode" XPath="StosMap[@Name='#VolumeImageGroupName']">
  		  <Iterate VariableName="StosGroupNode" Root="BlockNode" XPath="StosGroup[@Name='#VolumeImageGroupName#VolumeImageDownsample']">
          	<PythonCall Function="block.AssembleStosOverlays" GroupNode="#StosGroupNode"/>
          </Iterate>
      </Iterate> -->		

			<Iterate VariableName="StosGroupNode" Root="BlockNode" XPath="StosGroup[@Name='#VolumeImageGroupName#VolumeImageDownsample']">
				<Iterate VariableName="TransformNodeObj" Root="StosGroupNode" XPath="SectionMappings/Transform">
					<PythonCall Function="block.SectionToVolumeImage" TransformNode="#TransformNodeObj"/>
				</Iterate>
			</Iterate>
		</Iterate>
	</Pipeline>

	<Pipeline Name="MosaicToVolume" Description="Used after slice to volume.  Creates new mosaic transforms that map tiles directly into the volume space.  This is done by passing the mosaic transform through a slice-to-volume transformation.  Assemble can then be used to produce volume registered images.">   
		<Arguments>
			<Argument flag="-Channels"  default="*" dest="ChannelsRegEx" type="str" help="Regular expression describing channels to be processed" required="False"/>
			<Argument flag="-InputDownsample" dest="StosDownsample" default="1" type="int" help="Downsample level of input stosgroup" required="False"/>
			<Argument flag="-InputMap"  default="SliceToVolume" dest="InputMapName" type="str" help="Name of output group" required="False"/>
			<Argument flag="-InputGroup" default="SliceToVolume" dest="InputStosGroup" type="str" required="False" help="Name of stos group to pass mosaic transforms through"/>
			<Argument flag="-InputTransform" default="Grid" dest="InputTransformName" type="str" required="False" help="Mosaic transform to pass through slice-to-slice transform"/>
			<Argument flag="-OutputTransform" default="ChannelToVolume" dest="OutputTransform" type="str" required="False" help="Name of output transform mapping a channel to a volume"/>
		</Arguments>

		<Iterate VariableName="BlockNode" XPath="Block">
			<Select VariableName="StosMapNode" XPath="StosMap[@Name='#InputMapName']"/>
			<Select VariableName="StosGroupNode" Root="BlockNode" XPath="StosGroup[@Name='#InputStosGroup#StosDownsample']"/>
			
			<PythonCall Function="block.BuildMosaicToVolumeTransforms" BlockNode="#BlockNode" ChannelsRegEx="#ChannelsRegEx" InputTransformName="#InputTransformName" OutputTransformName="#OutputTransform"/>

			<!--
			<Iterate VariableName="ChannelNode" XPath="Section/Channel">
				<RequireMatch Attribute="Name" RegEx="#ChannelsRegEx"/>

				<Select VariableName="TransformNode" XPath="Transform[@Name='#InputTransform']"/> 
				<PythonCall Function="block.BuildMosaicToVolumeTransforms"  OutputTransformName="#OutputTransform"/>
			</Iterate>-->
		</Iterate>
	</Pipeline>

	<Pipeline Name="ExportImages" Description="Copies images of sections to an output directory">   
		<Arguments>
			<Argument flag="-Channels" dest="ChannelRegEx" default="*" help="Regular expression describing channels to be assembled" required="False"/>
			<Argument flag="-Filters" dest="FilterRegEx" default="(?![M|m]ask)" help="Regular expression describing filters to be assembled" required="False"/>
			<Argument flag="-Downsample" dest="Downsample" type="int" default="1" help="Downsample output images by this factor" required="False"/>
			<Argument flag="-Output" dest="OutputPath" help="Directory to move assembled images to" required="False"/>
		</Arguments>
		
		<Iterate VariableName="ChannelNode" XPath="Block/Section/Channel">
			<RequireMatch Attribute="Name" RegEx="#ChannelRegEx"/>
			
			<Iterate VariableName="FilterNodeObj" XPath="Filter">
				<RequireMatch Attribute="Name" RegEx="#FilterRegEx"/>
				
				<PythonCall Function="reporting.CopyImage" OutputDir="#OutputPath" FilterNode="#FilterNodeObj" Downsample="#Downsample"/>
			</Iterate>
		</Iterate>
	</Pipeline>

</Pipelines>